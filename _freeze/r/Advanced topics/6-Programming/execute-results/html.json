{
  "hash": "ab5bc5a585bfa1299040bf971adf1e72",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Programming Essentials\neditor: source\ndate: today\n---\n\nIn this workshop we cover the building blocks for developing more complex code, looking at\n\n* Understanding variable types and methods\n* Conditionals\n* Loops\n* Custom functions and modules\n\n## Directing traffic with conditionals\nIn the first half of this session we'll look at two types of control flows: **conditionals** and **loops**.\n\nConditionals allow you to put \"gates\" in your code, only running sections if a certain **condition** is true. They are common to most programming languages.\n\nIn R, they are called `if` statements, because you use the `if` command. For example,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (5 > 0) {\n  print(\"We're inside the if statement\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"We're inside the if statement\"\n```\n\n\n:::\n:::\n\n\nThe line `print(\"We're inside the if statement\")` **will only run if `5 > 0` is true**. If not, it'll get skipped.\n\nCurly brackets are essential. Only code inside them will be governed by conditional\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (5 > 0) {\n  print(\"We're inside the if statement\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"We're inside the if statement\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(\"This code always runs\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"This code always runs\"\n```\n\n\n:::\n:::\n\n\nWatch what happens if we change the condition\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (5 > 10) {\n  print(\"We're inside the if statement\")\n}\n\nprint(\"This code always runs\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"This code always runs\"\n```\n\n\n:::\n:::\n\n\nNow, the first line **doesn't run**. That's the essence of a conditional.\n\nThere's not much point to using a condition that will always be true. Typically, you'd use a variable in the condition, for example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npet_age <- 10\n\nif (pet_age > 10) {\n  print(\"My pet is older than 10\")\n}\n```\n:::\n\n\n### Logical operators\n\nHere is a table of the different operators you can make conditions with. When you run them, they always return either `True` or `False`. \n\n| Operator | True example | Description |\n| --- | --- | --- |\n| `==` | `10 == 10` | Same value and type |\n| `!=` | `\"10\" != 10` | Different value **or** type |\n| `>` | `10 > 5` | Greater than |\n| `>=` | `10 >= 10` | Greater than or equal to |\n| `<` | `5 < 10` | Less than |\n| `<=` | `5 <= 10` | Less than or equal to |\n| `&&` | `10 == 10 && \"apple\" == \"apple\"` | Only true if **both** conditions are true. |\n| `||` | `10 == 10 || \"a\" == \"b\"` | Always true if **one** condition is true.|\n\n### `elif` and `else`\n\n`if` statements only run if the condition is **True**. What happens if its **False**? That's what the `else` command is for, it's like a net that catches anything that slipped past `if`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npet_age <- 5\n\nif (pet_age > 10) {\n  print(\"My pet is older than 10\")\n} else {\n  print(\"My pet is 10 or younger\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"My pet is 10 or younger\"\n```\n\n\n:::\n:::\n\n\n> `else` also needs curly brackets!\n\nCheck what happens when you change the age from 5 to 15.\n\nFinally, what if you wanted to check another condition **only if the first one fails**? That's what `else if` is for. It's another if statement but it only runs if the first fails.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npet_age = 5\n\nif (pet_age > 10) {\n  print(\"My pet is older than 10\")\n} else if (pet_age < 5) {\n  print(\"My pet is younger than 5\")\n} else {\n  print(\"My pet is 10 or younger\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"My pet is 10 or younger\"\n```\n\n\n:::\n:::\n\n\nYou can include as many as you'd like\n\n\n::: {.cell}\n\n```{.r .cell-code}\npet_age = 5\n\nif (pet_age > 10) {\n  print(\"My pet is older than 10\")\n} else if (pet_age < 5) {\n  print(\"My pet is younger than 5\")\n} else if (pet_age < 1) {\n  print(\"My pet is freshly born\")\n} else {\n  print(\"My pet is 10 or younger\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"My pet is 10 or younger\"\n```\n\n\n:::\n:::\n\n\n## Repeat after me\n\nSometimes you need to repeat a task multiple times. Sometimes hundreds. Maybe you need to loop through 1 million pieces of data. Not fun.\n\nR's loops offer us a way to run a section of code multiple times. There are two types: `for` loops, which run the code once for each element in a sequence (like a list or string), and `while` loops, which run until some condition is false.\n\n### `while` loops\nThese are almost the same as `if` statements, except for the fact that they run the code multiple times. Let's begin with a basic conditional\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber <- 1\n\nif (number < 5) {\n  paste(number, \"is less than 10.\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1 is less than 10.\"\n```\n\n\n:::\n:::\n\n\n> The `paste` function lets you print multiple things together\n\nWhat if we wanted to check all the numbers between 5 and 10? We can use a while loop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber <- 1\n\nwhile (number < 5) {\n  print(paste(number, \"is less than 10.\"))\n  number <- number + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1 is less than 10.\"\n[1] \"2 is less than 10.\"\n[1] \"3 is less than 10.\"\n[1] \"4 is less than 10.\"\n```\n\n\n:::\n:::\n\n\n> We need to include `paste` inside `print` because we're doing it multiple times.\n\nWe've done two things\n\n1. Replace `if` with `while`\n2. Introduce `number = number + 1` to increase the number each time.\n\n> Without step 2, we'd have an **infinite loop** -- one that never stops, because the condition would always be true!\n\nWhile loops are useful for repeating code an indeterminate number of times.\n\n### `for` loops\nRealistically, you're most likely to use a **for** loop. They're inherently safer (you can't have an infinite loop) and often handier.\n\nIn R, `for` loops iterate through a sequence, like the objects in a list. This is more like other languages' `foreach`, than most's `for`.\n\nLet's say you have a vector of different fruit\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_of_fruits <- c(\"apple\", \"banana\", \"cherry\")\n```\n:::\n\n\nand you want to run a section of code on `\"apple\"`, then `\"banana\"`, then `\"cherry\"`. Maybe you want to know which ones have the letter \"a\". We can start with a `for` loop\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_of_fruits <- c(\"apple\", \"banana\", \"cherry\")\n\nfor (fruit in list_of_fruits) {\n  print(fruit)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apple\"\n[1] \"banana\"\n[1] \"cherry\"\n```\n\n\n:::\n:::\n\n\nThis loop's job is to print out the variable `fruit`. But where is `fruit` defined? Well, the `for` loop runs `print(fruit)` for every element of `list_of_fruits`, **storing the current element in the variable `fruit`**. If we were to write it out explicitly, it would look like\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit <- list_of_fruits[1]\nprint(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apple\"\n```\n\n\n:::\n\n```{.r .cell-code}\nfruit <- list_of_fruits[2]\nprint(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"banana\"\n```\n\n\n:::\n\n```{.r .cell-code}\nfruit <- list_of_fruits[3]\nprint(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cherry\"\n```\n\n\n:::\n:::\n\n\nLet's return to our goal: working out which ones have an \"a\". We need to put a **conditional** inside the loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_of_fruits <- c(\"apple\", \"banana\", \"cherry\")\n\nfor (fruit in list_of_fruits) {\n    if (grepl(\"a\", fruit)) { \n      print(paste(\"a is in\", fruit))\n    }\n    else {\n      print(paste(\"a is not in\", fruit))\n    }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a is in apple\"\n[1] \"a is in banana\"\n[1] \"a is not in cherry\"\n```\n\n\n:::\n:::\n\n\nFinally, it's often convenient to loop through a list of numbers. R makes this easy with the `x:y` notation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\ncontains all the integers between $1$ and $10$. To loop through each,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n```\n\n\n:::\n:::\n\n\nThe advantage of this approach is that we can loop through many numbers:\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:1000) {\n  print(i)\n}\n```\n:::\n\n\nThis can be useful if you need to loop through multiple objects by indexing. We'll spare you the output here.\n\n### Mapping with purrr\n\nConsider the follow situation. You have a dataset, and want to apply a function to *every* column. Or maybe some columns. What to do?\n\nYou *could* loop over them with a for loop. Alternatively, you could use the mapping functions in purrr, which simplifies the code.\n\nWhat is a map? Generally, a map takes *something* and makes it *something else*. So far, that's the same a function. The difference is that a map takes lots of things and translates them all in the same way. For example, a geographical map takes life-sized locations and transforms them all in the same way to a hand-sized piece of paper.\n\nEssentially, maps are a way of transforming a selection of variables in the same way. We'll start by brining in the `purrr` library\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n```\n:::\n\n\nLet's use the same data as in the statistics session:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nplayers <- read.csv(\"../../data/Players2024.csv\")\nplayers <- players %>% filter(positions != \"Missing\", height_cm > 100)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n:::\n\n\nWhat if you want the median value from *all* columns? We can use the `map_dbl()` function to map *doubles* (long decimal numbers):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(players, median)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]):\nargument is not numeric or logical: returning NA\nWarning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]):\nargument is not numeric or logical: returning NA\nWarning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]):\nargument is not numeric or logical: returning NA\nWarning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]):\nargument is not numeric or logical: returning NA\nWarning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]):\nargument is not numeric or logical: returning NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       name  birth_date   height_cm   positions nationality         age \n         NA          NA         183          NA          NA          25 \n       club \n         NA \n```\n\n\n:::\n:::\n\n\nDon't worry about the warnings - they're just there because you can't take the median of a non-numeric variable. To check which ones are, we can map the logical operator `is.numeric`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_lgl(players, is.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       name  birth_date   height_cm   positions nationality         age \n      FALSE       FALSE        TRUE       FALSE       FALSE        TRUE \n       club \n      FALSE \n```\n\n\n:::\n:::\n\n\nWe can use the pipe here,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplayers %>% map_lgl(is.numeric)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       name  birth_date   height_cm   positions nationality         age \n      FALSE       FALSE        TRUE       FALSE       FALSE        TRUE \n       club \n      FALSE \n```\n\n\n:::\n:::\n\n\nLet's select the numeric columns and look at the medians again\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplayers %>% \n  select_if(is.numeric) %>%\n  map_dbl(median)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nheight_cm       age \n      183        25 \n```\n\n\n:::\n:::\n\n\nWe can also create custom functions. We use `.x` to refer to the variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplayers %>% \n  select_if(is.numeric) %>%\n  map_dbl(~max(.x) - min(.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nheight_cm       age \n       46        27 \n```\n\n\n:::\n:::\n\n\n## Building your own machines\n\nWe'll wrap this session up by looking at custom functions. So far, we've only used built-in functions or those from other people's modules. But we can make our own!\n\nWe've only ever **called** functions - this is what we do when we use them. All functions need a **definition**, this is the code that gets run when they're called.\n\n### The function definition\n\nFunctions are machines. They take some inputs, run some code with those inputs, and spit out **one** output. We need to define how they work before we use them. We should specify\n\n* A name\n* Some inputs\n* The code to run (the machine itself)\n\nWe include these in three steps\n\n1. The first line of the function definition (the *function signature*) specifies the name and inputs\n2. We then **indent** all the code we want to run with our inputs\n3. We end with a `return` statement, specifying the output\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninsert_function_name_here <- function(input_1_name, input_2_name, ...) {\n  # Code code code\n}\n```\n:::\n\n\nFor example, let's create a function that converts centimetres to metres.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncm_to_m <- function(value_in_cm) {\n    value_in_cm / 100\n}\n```\n:::\n\n\nTaking it apart, we have\n\n* **Name**: `cm_to_m`\n* **Inputs** (just one): `value_in_cm`\n* **Code** (just one line): `value_in_cm / 100`\n\nImportantly, **nothing appears when you run this code**. Why? Because you've only defined the function, *you haven't used it yet*.\n\nTo use this function, we need to call it. Let's convert $10\\text{ cm}$ to $\\text{m}$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncm_to_m <- function(value_in_cm) {\n    value_in_cm / 100\n}\n\ncm_to_m(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1\n```\n\n\n:::\n:::\n\n\nWhen we call the function, it runs with `value_in_cm <- 10`.\n\nThat's it! Every function that you use, built-in or imported, looks like this.\n\nBecause functions must be defined before called, and defining them produces no output, **best practice is to place functions at the top of your script**, below the import statements.\n\n#### Return values and default values\n\nOne quirk of R functions is that, by default, they return the output of the line. Let's add a new line that prints the message \"$x\\text{ cm} = y\\text{ m}$\". We'll need to also save our calculation in the process:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncm_to_m <- function(value_in_cm) {\n    value_in_m <- value_in_cm / 100\n    print(paste(value_in_cm, \"cm =\", value_in_m, \"m\"))\n}\n\ncm_to_m(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"10 cm = 0.1 m\"\n```\n\n\n:::\n:::\n\n\nIt works, but we have a problem. The output of the function is the **whole message**, not the value. The easiest way to fix this is to call the output on the last line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncm_to_m <- function(value_in_cm) {\n    value_in_m <- value_in_cm / 100\n    print(paste(value_in_cm, \"cm =\", value_in_m, \"m\"))\n    value_in_m\n}\n\ncm_to_m(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"10 cm = 0.1 m\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1\n```\n\n\n:::\n:::\n\n\nAlternatively, you can use the `return()` function to exit before the end and manually specify the output.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}